<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<title>tsmerge monitor</title>
<style>
body {
    font-family: "Open Sans", Arial, sans-serif;
}
.rx_station-stat-label {
    font-size: 1.1em;
}
.rx_station-stat {
    display: block-inline;
    margin-left: 12px;
    width: 35px;
    font-size: 1.1em;
    font-weight: bold;
}
.rx_graph-legend {
  display:inline-block;
  font-size: 1.3em;
}
.font-red {
  color: rgba(255, 0, 0, 1);
}
.font-green {
  color: rgba(0, 255, 0, 1);
}
.font-blue {
  color: rgba(0, 0, 255, 1);
}
.font-yellow {
  color: rgba(255, 255, 0, 1);
}
</style>
<link rel="stylesheet" href="/libs/bootstrap-3.3.7/css/bootstrap.min.css">
</head>
<body>
<div id="page-container" class="container">
<div class="page-header">
  <h1>HAMTV TS Merger Monitor</h1>
</div>

<h2>Receiver Stations</h2>
<div id="rx_stations_row" class="row"></div>

<h3>Output Contribution</h3>
<canvas id="output_stations_graph" width="700" height="100"></canvas>
<div class="rx_graph-legend">
  <span class="glyphicon glyphicon-minus font-red"></span><span id="graph-legend-0"></span><br>
  <span class="glyphicon glyphicon-minus font-green"></span><span id="graph-legend-1"></span><br>
  <span class="glyphicon glyphicon-minus font-blue"></span><span id="graph-legend-2"></span><br>
  <span class="glyphicon glyphicon-minus font-yellow"></span><span id="graph-legend-3"></span><br>
</div>
<div id="output_stations"></div>

<h2>Server Status</h2>
tsmerge: <span id="tsmerge_server"></span><br />
RX Buffer Queue: <span id="rx_buffer_queue"></span> packets<br />
RX Buffer Loss : <span id="rx_buffer_loss"></span> packets<br />
<h4>Threads</h4>
<div id="server_threads"></div>

</div>
</body>
<script src="/libs/jquery-3.1.1.min.js"></script>
<script src="/socket.io/socket.io.js"></script>
<script src="/libs/bootstrap-3.3.7/js/bootstrap.min.js"></script>
<script src="/libs/smoothie.js"></script>
<script>

var selected_count_valid = 0;
var selected_total_count = 0;

var station_contrib_graphOptions = [
  { strokeStyle: 'rgba(255, 0, 0, 1)', fillStyle: 'rgba(255, 0, 0, 0.3)', lineWidth: 3 },
  { strokeStyle: 'rgba(0, 255, 0, 1)', fillStyle: 'rgba(0, 255, 0, 0.3)', lineWidth: 3 },
  { strokeStyle: 'rgba(0, 0, 255, 1)', fillStyle: 'rgba(0, 0, 255, 0.3)', lineWidth: 3 },
  { strokeStyle: 'rgba(255, 255, 0, 1)', fillStyle: 'rgba(255, 255, 0, 0.3)', lineWidth: 3 }
];

var last_stat = 0;
var rx_stations = [null, null, null, null];
var rx_stations_timegraph = new SmoothieChart({
  millisPerPixel: 20,
  grid: {
    strokeStyle: '#555555',
    lineWidth: 1,
    millisPerLine: 1000,
    verticalSections: 4
    }
  }
);
rx_stations.forEach(function(station, station_index)
{
  rx_stations[station_index] = {
    /* Cached Panel Selector */
    "panel": null,
    
    /* merger is reporting station connected */
    "connected": false,
    /* station is currently streaming packets */
    "streaming": false,
    /* station has been selected as output */
    "selecting": false,
    /* station is losing data on network upload */
    "netlosing": false,
    
    /* Callsign of station */
    "callsign": "",
    
    /* Stream counter value (updated by data feed) */
    "streamed": 0,
    /* Selected counter value (updated by data feed) */
    "selected": 0,
    /* Network loss counter value (updated by data feed) */
    "netlost": 0,
    
    /* Previous stream counter value (updated by UI render) */
    "previous_streamed": 0,
    /* Previous selected counter value (updated by UI render) */
    "previous_selected": 0,
    /* Previous network loss counter value (updated by UI render) */
    "netlost_selected": 0,
    
    /* Selected share from previous sample */
    "previous_selected_count": 0,
    "previous_selected_percent": 0,
    
    /* Contribution graph data */
    "graph_data": new TimeSeries(),
    "graph_options": station_contrib_graphOptions[station_index],
  };
  
  /* Set up contribution graph data */
  rx_stations[station_index].graph_data.append(new Date().getTime(), 0);
  rx_stations_timegraph.addTimeSeries(
    rx_stations[station_index].graph_data,
    rx_stations[station_index].graph_options
  );
});
rx_stations_timegraph.streamTo(document.getElementById('output_stations_graph'), 100);

function create_stations()
{
  var colwidth = Math.floor(12/rx_stations.length);
  rx_stations.forEach(function(station, station_id)
  {
    var col = $('<div></div>')
      .attr('id', 'column-rx_station-'+station_id)
      .attr('class', 'col-md-'+colwidth);
        
    station.panel = $('<div></div>')
      .attr('id', 'panel-rx_station-'+station_id)
      .attr('class', 'panel panel-default');
    
    var panel_heading = $('<div></div>')
      .attr('class', 'panel-heading');
    
    panel_heading.append($('<h3></h3>')
                            .attr('id','title-rx_station-'+station_id)
                            .attr('class', 'panel-title')
                         );
    
    station.panel.append(panel_heading);
    
    var panel_body = $('<div></div>')
                        .attr('class', 'panel-body');
    
    /* Graphic here? */
                        
    panel_body.append($('<hr />'));
    
    panel_body.append($('<span></span>')
                        .attr('class', 'rx_station-stat-label')
                        .text('Last Data: '));
    panel_body.append($('<span></span>')
                        .attr('id','rx_station-active-'+station_id)
                        .attr('class', 'rx_station-stat'))
                        .append($('<br />'));
    
    panel_body.append($('<span></span>')
                        .attr('class', 'rx_station-stat-label')
                        .text('Total TS Packets: '));
    panel_body.append($('<span></span>')
                        .attr('id','rx_station-total-'+station_id)
                        .attr('class', 'rx_station-stat'))
                        .append($('<br />'));
    
    panel_body.append($('<span></span>')
                        .attr('class', 'rx_station-stat-label')
                        .text('Network Loss: '));
    panel_body.append($('<span></span>')
                        .attr('id','rx_station-netloss-'+station_id)
                        .attr('class', 'rx_station-stat'))
                        .append($('<br />'));
    
    panel_body.append($('<span></span>')
                        .attr('class', 'rx_station-stat-label')
                        .text('Selected: '));
    panel_body.append($('<span></span>')
                        .attr('id','rx_station-selected-'+station_id)
                        .attr('class', 'rx_station-stat')
                        .append($('<br />')));
    
    station.panel.append(panel_body);
    col.append(station.panel);
    $("#rx_stations_row").append(col);
  });
}

function render_stations()
{
  var selected_total_count = 0;

  rx_stations.forEach(function(station, station_id)
  {
    /** Update station status **/
    /* streamed status */
    if(station.streamed > station.previous_streamed)
    {
      station.streaming = true;
      station.previous_streamed = station.streamed;
    }
    else
    {
      station.streaming = false;
      station.previous_streamed = station.streamed;
    }
    /* selecting status */
    if(station.selected > station.previous_selected)
    {
      station.selecting = true;
      
      station.previous_selected_count = (station.selected - station.previous_selected);
      selected_total_count += station.previous_selected_count;
      
      station.previous_selected = station.selected;
    }
    else
    {
      station.selecting = false;
      station.previous_selected = station.selected;
      station.previous_selected_count = 0;
    }
    /* netlosing status */
    if(station.netlost > station.previous_netlost)
    {
      station.netlosing = true;
      station.previous_netlost = station.netlost;
    }
    else
    {
      station.netlosing = false;
      station.previous_netlost = station.netlost;
    }
  
    /* Set panel colour based on station status */
    if(station.streaming)
    {
      if(station.selecting)
      {
        /* Station is streaming and selected for output */
        /* Green panel - set if not already set */
        if(!station.panel.hasClass('panel-success'))
        {
          station.panel
            .removeClass('panel-default')
            .removeClass('panel-info')
            .addClass('panel-success');
        }
      }
      else
      {
        /* Station is streaming, but not selected */
        /* Blue panel - set if not already set */
        if(!station.panel.hasClass('panel-info'))
        {
          station.panel
            .removeClass('panel-default')
            .removeClass('panel-success')
            .addClass('panel-info');
        }
      }
    }
    else
    {
      /* Station is not streaming */
      /* Grey panel - set if not already set */
      if(!station.panel.hasClass('panel-default'))
      {
        station.panel
          .removeClass('panel-info')
          .removeClass('panel-success')
          .addClass('panel-default');
      }
    }
    
    /* Set panel title */
    $('#title-rx_station-'+station_id)
      .text(station.callsign);

    /* Set graph legend */
    $('#graph-legend-'+station_id)
      .text(station.callsign);
      
    /* Set text stats */
    $('#rx_station-total-'+station_id)
      .text(station.streamed);
    $('#rx_station-selected-'+station_id)
      .text(station.selected);
    $('#rx_station-netloss-'+station_id)
      .text(station.netlost);
  });
  
  var graphTime = new Date().getTime();

  if(selected_total_count > 0)
  {
    rx_stations.forEach(function(station, station_id)
    {
      rx_stations[station_id].previous_selected_percent = Math.min(100,100*station.previous_selected_count
                          / selected_total_count);
      rx_stations[station_id].graph_data.append(graphTime, station.previous_selected_percent);
    });
  }
  else
  {
    rx_stations.forEach(function(station, station_id)
    {
      rx_stations[station_id].previous_selected_percent = 0;
      rx_stations[station_id].graph_data.append(graphTime, 0);
    });
  }
  
  setTimeout(render_stations,100);
}
create_stations();
render_stations();

function update_stations(stations)
{
  rx_stations.forEach(function(station,station_index)
  {
    rx_stations[station_index].connected = false;
  });

  stations.forEach(function(station,station_index)
  {
    rx_stations[station.id].connected = true;
    rx_stations[station.id].callsign = station.callsign;
    rx_stations[station.id].streamed = station.total_received;
    rx_stations[station.id].selected = station.selected;
    rx_stations[station.id].netlost = station.lost;
  });

}

var socket = io();
socket.on('data', function (jdata)
{
  //console.log(jdata);
  var data = JSON.parse(jdata);
  //console.log(data);
  last_stat = (new Date());
    
  switch(data.type)
  {
    case 'udprxbuffer':
      var queue = data.head - data.tail;
      if(queue < 0)
      {
        queue = queue + 1024;
      }
      $("#rx_buffer_queue").text(queue);
      $("#rx_buffer_loss").text(data.loss);
      break;
      
    case 'stations':
      update_stations(data.stations);
      break;
      
    case 'selection':
      /* Only use if relative selected count gave us no information */
      if(selected_count_valid==0)
      {
        //TODO
      }
      break;
    
    case 'threads':
        var threads_list = $("<ul></ul>");
        for(var i=0; i<data.threads.length; i++)
        {
            threads_list.append(
                $("<li></li>").text(
                    data.threads[i].name +
                    ": "+
                    data.threads[i].cpu_percent +
                    "%"
                )
            );
        }
        $("#server_threads").empty();
        $("#server_threads").append(threads_list);
        break;
      
    default:
      console.log("Unknown data type: "+data.type);
      break;
  }
});

function checkServer()
{
  if(last_stat > (new Date() - 2000))
  {
    $("#tsmerge_server").text("Running");
  }
  else if(last_stat > 0)
  {
    $("#tsmerge_server").text("Stopped");
  }
  setTimeout(checkServer, 100);
}
checkServer();

function dateStringFromEpoch(epoch)
{
  var date = new Date(epoch);
  return date.toDateString() + " " + date.toLocaleTimeString();
}
</script>
</html>
