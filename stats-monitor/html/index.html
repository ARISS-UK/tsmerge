<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<title>tsmerge monitor</title>
<style>
body {
    font-family: "Open Sans", Arial, sans-serif;
}
</style>
</head>
<body>
<h1>tsmerge</h1>

<h2>Output Contribution</h2>
<canvas id="output_stations_graph" width="500" height="100"></canvas>
<div id="output_stations"></div>

<h2>Connected Stations</h2>
<div id="rx_stations"></div>

<h2>Server Status</h2>
tsmerge: <span id="tsmerge_server"></span><br />
RX Buffer Queue: <span id="rx_buffer_queue"></span> packets<br />
RX Buffer Loss : <span id="rx_buffer_loss"></span> packets<br />
<h4>Threads</h4>
<div id="server_threads"></div>

</body>
<script src="/libs/jquery-3.1.1.min.js"></script>
<script src="/socket.io/socket.io.js"></script>
<script src="/libs/smoothie.js"></script>
<script>

var selected_count_valid = 0;
var selected_total_count = 0;

var last_stat = 0;
var station_data = [10];
var no_connected_stations = 0;
var selected_counts = [10];
var selected_new_counts = [10];
for(var i; i<10; i++)
{
  selected_counts[i] = 0;
  selected_new_counts[i] = 0;
}


/* Hardcoded for 4x stations (TODO: Dynamic) */
var station_contrib_data = [new TimeSeries(), new TimeSeries(), new TimeSeries(), new TimeSeries()];
var station_contrib_graphOptions = [
  { strokeStyle: 'rgba(255, 0, 0, 1)', fillStyle: 'rgba(255, 0, 0, 0.1)', lineWidth: 3 },
  { strokeStyle: 'rgba(0, 255, 0, 1)', fillStyle: 'rgba(0, 255, 0, 0.1)', lineWidth: 3 },
  { strokeStyle: 'rgba(0, 0, 255, 1)', fillStyle: 'rgba(0, 0, 255, 0.1)', lineWidth: 3 },
  { strokeStyle: 'rgba(255, 255, 0, 1)', fillStyle: 'rgba(255, 255, 0, 0.1)', lineWidth: 3 }
];
var selection_timegraph = new SmoothieChart({ millisPerPixel: 20, grid: { strokeStyle: '#555555', lineWidth: 1, millisPerLine: 1000, verticalSections: 4 }});
for (var i = 0; i < 4; i++)
{
  station_contrib_data[i].append(new Date().getTime(), 0);
  selection_timegraph.addTimeSeries(station_contrib_data[i], station_contrib_graphOptions[i]);
}
selection_timegraph.streamTo(document.getElementById('output_stations_graph'), 200);


var socket = io();
socket.on('data', function (jdata)
{
  //console.log(jdata);
  var data = JSON.parse(jdata);
  //console.log(data);
  last_stat = (new Date());
    
  switch(data.type)
  {
    case 'udprxbuffer':
      var queue = data.head - data.tail;
      if(queue < 0)
      {
        queue = queue + 1024;
      }
      $("#rx_buffer_queue").text(queue);
      $("#rx_buffer_loss").text(data.loss);
      break;
      
    case 'stations':
      var selected_count = 0;
      if(data.stations.length > 0)
      {
        if(no_connected_stations)
        {
          no_connected_stations = 0;
          $("#rx_stations").empty();
        }
        for(var i=0; i<data.stations.length; i++)
        {
          if($("#rx_station_" + data.stations[i].id).length == 0)
          {
            $("#rx_stations").append(
              $("<div></div")
                  .attr('id',"rx_station_" + data.stations[i].id)
            );
          }
          station_div = $("#rx_station_" + data.stations[i].id);
          station_div.empty();
          station_div.append(
            $("<h4></h4>").text(data.stations[i].callsign),
            $("<ul></ul>").append(
              $("<li></li>").text("Connected since: "+dateStringFromEpoch(data.stations[i].connected)),
              $("<li></li>").text("Last TS Packet: "+dateStringFromEpoch(data.stations[i].timestamp)),
              $("<li></li>").text("Total TS Packets: "+data.stations[i].total_received),
              $("<li></li>").text("Network Loss: "+data.stations[i].lost),
              $("<li></li>").text("Selected: "+data.stations[i].selected)
            )
          );
          station_data[i] = data.stations[i];
          selected_counts[i] = selected_new_counts[i];
          selected_new_counts[i] = data.stations[i].selected;
          
          selected_count = selected_count + data.stations[i].selected;
        }
      }
      else
      {
        if(!no_connected_stations)
        {
          no_connected_stations = 1;
          $("#rx_stations").empty();
          $("#rx_stations").text("No stations connected.");
        }
      }
      
      if(selected_total_count > selected_count)
      {
        /* Stations have probably reset while the page is open , so reset counter */
        selected_total_count = selected_count;
      }
      
      /* Check if we can use relative selected count to quantify station contribution */
      if(selected_count > selected_total_count)
      {
        selected_count_valid = 1;
        $("#output_stations").empty();
        var graphTime = new Date().getTime();
        for(var i=0;i<4;i++)
        {
          if(selected_new_counts[i] > selected_counts[i])
          {
            /* Selected count for this station has incremented, so it has a share */
            var percentage = Math.min(100,100*(selected_new_counts[i] - selected_counts[i])
                              / (selected_count - selected_total_count));
            $("#output_stations").append(
              $("<b></b>").text(station_data[i].callsign+": "),
              $("<span></span>").text(percentage+"%")
            );
            station_contrib_data[i].append(graphTime, percentage);
          }
          else
          {
            station_contrib_data[i].append(graphTime, 0);
          }
        }
        selected_total_count = selected_count;
      }
      else
      {
        selected_count_valid = 0;
        if($("#output_stations").length==1)
        {
          $("#output_stations").text("No stations streaming.");
        }
      }
      break;
      
    case 'selection':
      /* Only use if relative selected count gave us no information */
      if(selected_count_valid==0)
      {
        $("#output_stations").empty();
        /* If last packet was >2s ago, assume it's stale and ignore */
        
        if(typeof station_data[data.id] == "undefined")
        {
          $("#output_stations").text("No stations streaming.");
          var graphTime = new Date().getTime();
          for(var i; i<station_contrib_data.length; i++)
          {
            station_contrib_data[i].append(graphTime, 0);
          }
        }
        else if(station_data[data.id].timestamp > (new Date() - 2000))
        {
          $("#output_stations").append(
            $("<b></b>").text(data.callsign+": "),
            $("<span></span>").text("100%"),
            $("<br></br>")
          );
          var graphTime = new Date().getTime();
          for(var i; i<station_contrib_data.length; i++)
          {
            if(i==data.id)
              station_contrib_data[data.id].append(graphTime, 100);
            else
              station_contrib_data[data.id].append(graphTime, 0);
          }
              
        }
        else
        {
          $("#output_stations").text("No stations streaming.");
        }
      }
      break;
    
    case 'threads':
        var threads_list = $("<ul></ul>");
        for(var i=0; i<data.threads.length; i++)
        {
            threads_list.append(
                $("<li></li>").text(
                    data.threads[i].name +
                    ": "+
                    data.threads[i].cpu_percent +
                    "%"
                )
            );
        }
        $("#server_threads").empty();
        $("#server_threads").append(threads_list);
        break;
      
    default:
      console.log("Unknown data type: "+data.type);
      break;
  }
});

function checkServer()
{
  if(last_stat > (new Date() - 2000))
  {
    $("#tsmerge_server").text("Running");
  }
  else if(last_stat > 0)
  {
    $("#tsmerge_server").text("Stopped");
  }
  console.log(station_contrib_data[0].data.length);
  setTimeout(checkServer, 100);
}
checkServer();

function dateStringFromEpoch(epoch)
{
  var date = new Date(epoch);
  return date.toDateString() + " " + date.toLocaleTimeString();
}
</script>
</html>
